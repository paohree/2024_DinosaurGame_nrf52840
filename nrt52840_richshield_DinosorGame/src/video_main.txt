#include <zephyr/sys/util.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/led.h>
#include <zephyr/drivers/kscan.h>
#include <zephyr/devicetree.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(main, CONFIG_LOG_DEFAULT_LEVEL);

#define LED_NODE DT_COMPAT_GET_ANY_STATUS_OKAY(holtek_ht16k33)
#define KEY_NODE DT_CHILD(LED_NODE, keyscan)

const struct device *led; // 전역 변수 선언
const struct device *key;

#define GPIO_FAIL -1
#define GPIO_OK 0

static struct gpio_callback button0_cb_data;
static struct gpio_callback button1_cb_data;
static struct gpio_callback button2_cb_data;
static struct gpio_callback button3_cb_data;

#define LED0_NODE DT_ALIAS(led0)
#define LED1_NODE DT_ALIAS(led1)
#define LED2_NODE DT_ALIAS(led2)
#define LED3_NODE DT_ALIAS(led3)

static const struct gpio_dt_spec led0 = GPIO_DT_SPEC_GET(LED0_NODE, gpios);
static const struct gpio_dt_spec led1 = GPIO_DT_SPEC_GET(LED1_NODE, gpios);
static const struct gpio_dt_spec led2 = GPIO_DT_SPEC_GET(LED2_NODE, gpios);
static const struct gpio_dt_spec led3 = GPIO_DT_SPEC_GET(LED3_NODE, gpios);

#define SW0_NODE DT_ALIAS(sw0)
#define SW1_NODE DT_ALIAS(sw1)
#define SW2_NODE DT_ALIAS(sw2)
#define SW3_NODE DT_ALIAS(sw3)

static const struct gpio_dt_spec button0 = GPIO_DT_SPEC_GET(SW0_NODE, gpios);
static const struct gpio_dt_spec button1 = GPIO_DT_SPEC_GET(SW1_NODE, gpios);
static const struct gpio_dt_spec button2 = GPIO_DT_SPEC_GET(SW2_NODE, gpios);
static const struct gpio_dt_spec button3 = GPIO_DT_SPEC_GET(SW3_NODE, gpios);

void toggle_led(int led_id)
{
    static bool led_states[128] = {false};
    if (led_states[led_id]) {
        led_off(led, led_id);
    } else {
        led_on(led, led_id);
    }
    led_states[led_id] = !led_states[led_id];
}

void button0_work_handler(struct k_work *work)
{
    toggle_led(5);
}

void button1_work_handler(struct k_work *work)
{
    toggle_led(6);
}

void button2_work_handler(struct k_work *work)
{
    toggle_led(7);
}

void button3_work_handler(struct k_work *work)
{
    toggle_led(8);
}

K_WORK_DEFINE(button0_work, button0_work_handler);
K_WORK_DEFINE(button1_work, button1_work_handler);
K_WORK_DEFINE(button2_work, button2_work_handler);
K_WORK_DEFINE(button3_work, button3_work_handler);

void button0_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    printk("Button 0 pressed\n");
    k_work_submit(&button0_work);
}

void button1_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    printk("Button 1 pressed\n");
    k_work_submit(&button1_work);
}

void button2_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    printk("Button 2 pressed\n");
    k_work_submit(&button2_work);
}

void button3_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    printk("Button 3 pressed\n");
    k_work_submit(&button3_work);
}

int gpio_init(void)
{
    int err = GPIO_FAIL;

    // Set button0 interrupt
    printk("Setting button0 interrupt\n");

    err = gpio_is_ready_dt(&button0);
    if (!err) {
        printk("Error gpio_is_ready_dt button0 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&button0, GPIO_INPUT | GPIO_PULL_UP);
    if (err < 0) {
        printk("Error configuring button0 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_interrupt_configure_dt(&button0, GPIO_INT_EDGE_TO_ACTIVE);
    if (err != 0) {
        printk("Error configuring interrupt on button0 pin %d\n", err);
        return GPIO_FAIL;
    }
    gpio_init_callback(&button0_cb_data, button0_callback, BIT(button0.pin));
    gpio_add_callback(button0.port, &button0_cb_data);

    // Set button1 interrupt
    printk("Setting button1 interrupt\n");
    err = gpio_is_ready_dt(&button1);
    if (!err) {
        printk("Error gpio_is_ready_dt button1 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&button1, GPIO_INPUT | GPIO_PULL_UP);
    if (err < 0) {
        printk("Error configuring button1 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_interrupt_configure_dt(&button1, GPIO_INT_EDGE_TO_ACTIVE);
    if (err != 0) {
        printk("Error configuring interrupt on button1 pin %d\n", err);
        return GPIO_FAIL;
    }
    gpio_init_callback(&button1_cb_data, button1_callback, BIT(button1.pin));
    gpio_add_callback(button1.port, &button1_cb_data);

    // Set button2 interrupt
    printk("Setting button2 interrupt\n");
    err = gpio_is_ready_dt(&button2);
    if (!err) {
        printk("Error gpio_is_ready_dt button2 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&button2, GPIO_INPUT | GPIO_PULL_UP);
    if (err < 0) {
        printk("Error configuring button2 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_interrupt_configure_dt(&button2, GPIO_INT_EDGE_TO_ACTIVE);
    if (err != 0) {
        printk("Error configuring interrupt on button2 pin %d\n", err);
        return GPIO_FAIL;
    }
    gpio_init_callback(&button2_cb_data, button2_callback, BIT(button2.pin));
    gpio_add_callback(button2.port, &button2_cb_data);

    // Set button3 interrupt
    printk("Setting button3 interrupt\n");
    err = gpio_is_ready_dt(&button3);
    if (!err) {
        printk("Error gpio_is_ready_dt button3 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&button3, GPIO_INPUT | GPIO_PULL_UP);
    if (err < 0) {
        printk("Error configuring button3 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_interrupt_configure_dt(&button3, GPIO_INT_EDGE_TO_ACTIVE);
    if (err != 0) {
        printk("Error configuring interrupt on button3 pin %d\n", err);
        return GPIO_FAIL;
    }
    gpio_init_callback(&button3_cb_data, button3_callback, BIT(button3.pin));
    gpio_add_callback(button3.port, &button3_cb_data);

    // Set led0
    err = gpio_is_ready_dt(&led0);
    if (!err) {
        printk("Error gpio_is_ready_dt led0 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&led0, GPIO_OUTPUT_ACTIVE);
    if (err < 0) {
        printk("Error %d: failed to configure LED0 pin\n", err);
        return GPIO_FAIL;
    }

    // Set led1
    err = gpio_is_ready_dt(&led1);
    if (!err) {
        printk("Error gpio_is_ready_dt led1 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&led1, GPIO_OUTPUT_ACTIVE);
    if (err < 0) {
        printk("Error %d: failed to configure LED1 pin\n", err);
        return GPIO_FAIL;
    }

    // Set led2
    err = gpio_is_ready_dt(&led2);
    if (!err) {
        printk("Error gpio_is_ready_dt led2 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&led2, GPIO_OUTPUT_ACTIVE);
    if (err < 0) {
        printk("Error %d: failed to configure LED2 pin\n", err);
        return GPIO_FAIL;
    }

    // Set led3
    err = gpio_is_ready_dt(&led3);
    if (!err) {
        printk("Error gpio_is_ready_dt led3 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&led3, GPIO_OUTPUT_ACTIVE);
    if (err < 0) {
        printk("Error %d: failed to configure LED3 pin\n", err);
        return GPIO_FAIL;
    }

    return GPIO_OK;
}

static void keyscan_callback(const struct device *dev, uint32_t row, uint32_t column, bool pressed){
    LOG_INF("Row %d, column %d %s", row, column, pressed ? "pressed" : "released");
}

void main(void)
{
    int err;
    int i;

    printk("buttoninterrupt_example\n");

    err = gpio_init();
    if (err != GPIO_OK) {
        printk("Error gpio_init %d\n", err);
        return;
    }

    led = DEVICE_DT_GET(LED_NODE);
    if (!device_is_ready(led)) {
        LOG_ERR("LED device not ready");
        return;
    }

    key = DEVICE_DT_GET(KEY_NODE);
    if (!device_is_ready(key)) {
        LOG_ERR("Keyscan device not ready");
        return;
    }

    printk("LED and Keyscan devices ready\n");

    err = kscan_config(key, keyscan_callback);
    if (err) {
        LOG_ERR("Failed to add keyscan callback (err %d)", err);
        return;
    }

    led_set_brightness(led, 0, 0.5);
    for (i = 96; i < 128; i++) {
        led_on(led, i);
    }

    printk("Starting LED blink loop\n");
    while (1) {
        printk("Blinking LED on HT16K33\n");
        for (i = 32; i < 96; i++) {
            int ret = led_on(led, i);
            if (ret < 0) {
                LOG_ERR("Failed to turn on LED %d (err %d)", i, ret);
            }
            k_sleep(K_MSEC(50));
        }
        for (i = 95; i >= 32; i--) {
            int ret = led_off(led, i);
            if (ret < 0) {
                LOG_ERR("Failed to turn off LED %d (err %d)", i, ret);
            }
            k_sleep(K_MSEC(50));
        }
    }
}

