#include <zephyr/sys/util.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/led.h>
#include <zephyr/devicetree.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(main, CONFIG_LOG_DEFAULT_LEVEL);

#define LED_NODE DT_COMPAT_GET_ANY_STATUS_OKAY(holtek_ht16k33)

const struct device *led; // 전역 변수 선언

#define GPIO_FAIL -1
#define GPIO_OK 0

static struct gpio_callback button0_cb_data;

#define GROUND_START 96
#define GROUND_END 128

#define DINO_LED 80

bool is_jumping = false;
int dino_pos = DINO_LED;
int obstacle_pos = GROUND_END - 1;

#define LED0_NODE DT_ALIAS(led0)
static const struct gpio_dt_spec button0 = GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios);

void game_loop(struct k_work *work);
K_WORK_DELAYABLE_DEFINE(game_work, game_loop);

void button0_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    if (!is_jumping) {
        is_jumping = true;
        dino_pos -= 16; // Jump up one row
        printk("Dino jumps to %d\n", dino_pos);
    }
}

int gpio_init(void)
{
    int err = GPIO_FAIL;

    // Set button0 interrupt
    printk("Setting button0 interrupt\n");

    err = gpio_is_ready_dt(&button0);
    if (!err) {
        printk("Error gpio_is_ready_dt button0 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_configure_dt(&button0, GPIO_INPUT | GPIO_PULL_UP);
    if (err < 0) {
        printk("Error configuring button0 pin %d\n", err);
        return GPIO_FAIL;
    }

    err = gpio_pin_interrupt_configure_dt(&button0, GPIO_INT_EDGE_TO_ACTIVE);
    if (err != 0) {
        printk("Error configuring interrupt on button0 pin %d\n", err);
        return GPIO_FAIL;
    }
    gpio_init_callback(&button0_cb_data, button0_callback, BIT(button0.pin));
    gpio_add_callback(button0.port, &button0_cb_data);

    return GPIO_OK;
}

void game_loop(struct k_work *work)
{
    static int jump_counter = 0;
    static int game_speed = 500; // Game speed in milliseconds

    // Clear previous Dino position
    led_off(led, dino_pos);

    // Handle jumping logic
    if (is_jumping) {
        jump_counter++;
        if (jump_counter >= 5) { // Adjust jump duration for slower game speed
            dino_pos += 16; // Fall back down
            is_jumping = false;
            jump_counter = 0;
            printk("Dino falls to %d\n", dino_pos);
        }
    }

    // Set new Dino position
    led_on(led, dino_pos);

    // Move obstacle
    if (obstacle_pos >= GROUND_START) {
        led_off(led, obstacle_pos);
        obstacle_pos--;
        if (obstacle_pos < GROUND_START) {
            obstacle_pos = GROUND_END - 1; // Reset obstacle to the end
        } else {
            led_on(led, obstacle_pos);
        }
    }

    // Check for collision
    if (dino_pos == obstacle_pos) {
        printk("Collision detected at %d!\n", dino_pos);
        // Reset game or handle game over
        // For now, just reset the obstacle
        obstacle_pos = GROUND_END - 1;
    }

    // Schedule next iteration
    k_work_reschedule(&game_work, K_MSEC(game_speed));
}

void main(void)
{
    int err;
    printk("buttoninterrupt_example\n");

    err = gpio_init();
    if (err != GPIO_OK) {
        printk("Error gpio_init %d\n", err);
        return;
    }

    led = DEVICE_DT_GET(LED_NODE);
    if (!device_is_ready(led)) {
        LOG_ERR("LED device not ready");
        return;
    }

    printk("LED device ready\n");

    for (int i = GROUND_START; i < GROUND_END; i++) {
        led_on(led, i);
    }

    // Start game loop
    k_work_schedule(&game_work, K_NO_WAIT);
}
