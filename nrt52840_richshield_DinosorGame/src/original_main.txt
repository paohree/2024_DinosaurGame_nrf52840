/*
 * Copyright (c) 2019 Henrik Brix Andersen <henrik@brixandersen.dk>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

// #include <zephyr/drivers/led.h>
// #include <zephyr/drivers/kscan.h>
// #include <zephyr/devicetree.h>
// #include <zephyr/kernel.h>
// #include <zephyr/logging/log.h>

#include "gpios.h"

LOG_MODULE_REGISTER(main, CONFIG_LOG_DEFAULT_LEVEL);

#define LED_NODE DT_COMPAT_GET_ANY_STATUS_OKAY(holtek_ht16k33)
#define KEY_NODE DT_CHILD(LED_NODE, keyscan)

static void keyscan_callback(const struct device *dev, uint32_t row,
			     uint32_t column, bool pressed)
{
	LOG_INF("Row %d, column %d %s", row, column,
		pressed ? "pressed" : "released");
}

const struct device *const led = DEVICE_DT_GET(LED_NODE);
const struct device *const key = DEVICE_DT_GET(KEY_NODE);

int main(void)
{
	int err;
	int i;

	if (!device_is_ready(led)) {
		LOG_ERR("LED device not ready");
		return 0;
	}

	if (!device_is_ready(key)) {
		LOG_ERR("Keyscan device not ready");
		return 0;
	}

	err = kscan_config(key, keyscan_callback);
	if (err) {
		LOG_ERR("Failed to add keyscan callback (err %d)", err);
	}

    led_set_brightness(led, 0, 0.5);
	for (i = 96; i < 128; i++) {
		led_on(led, i);
	}

    int err2 = GPIO_FAIL;
    err2 = gpio_init();
    if(err2 != GPIO_OK)
    {
            printk("Error gpio_init %d\n", err2);
            return 0;
    }

	//while (1) {
		//printk("33333\n");
		for (i = 32; i < 48; i++) {
			//printk("wowdoge\n");
			led_on(led, i);
			k_sleep(K_MSEC(50));
		}
		//printk("ethereum\n");
		for (i = 47; i >= 32; i--) {
			//printk("nasdaq\n");
			led_off(led, i);
			k_sleep(K_MSEC(50));
		}
		//printk("bitcoin\n");
		//printk("444444\n");

	//}
	return 0;
}